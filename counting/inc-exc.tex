\section{容斥}
\subsection{容斥的元理论}
容斥本质上，是用好计数的东西去凑不好计数的东西。\par
我们下面用$s(C)$来表示事物$C$的计数。现在我们有一个很难计数的事物
$C_0$（比如说“恰好都合法”），然后我们寻找一些与$C_0$相关、且可以
粗略认为可以拼凑出$C_0$的事物$C_1, C_2, \ldots, C_n$（比如说“至
少那些不合法“），同时寻找与这些食物的性质相关的一组常数
$f_1, f_2, \ldots, f_n$，使得：
\[\sum_{i = 1}^n f_i s(C_i) = s(C_0)\]\par
对于常见的计数问题，我们令$s(C)$表示事物$C$是否合法，也就是说是一
个$0/1$值。
\subsection{二项式反演与广义容斥原理}
\[
\begin{aligned}
\sum_{i = 0}^n\binom n i a_i = b_n&\Longrightarrow
\sum_{i = 0}^n(-1)^{n - i}\binom n i b_i = a_n\\
\sum_{i = k}^n\binom i k a_i = b_k&\Longrightarrow
\sum_{i = k}^n(-1)^{k - i}\binom i k b_i = a_k
\end{aligned}
\]
\subsection{MIN-MAX 容斥}
很多时候，我们会出现“最小”好做但“最大”不可做的窘境，MIN-MAX容斥
营运而生。\par
MIN-MAX容斥就是说，对于一个集合$S$，其最大值$\max\{S\}$满足：\par
\[\max\{S\} = \sum_{T\subseteq S} (-1)^{|T| + 1}\min\{T\}\]\par
需要注意，这个式子是对偶的，也就是说把$\max,\min$互换式子仍然成
立。\par
这个东西比较套路化了……但是相关推柿子并不容易。

\section{容斥例题}
\subsection{容斥系数法例题}
\paragraph{题面}
求有多少\(1\ldots n\)的排列，使得\(\forall i, a_i\ne i\)。
\paragraph{解析}
我们要求的这个条件$C$就是所有位都错排。然后我们设计$C_0, C_1, \ldots, C_n$
表示至少有$0$位，至少有$1$位……至少有$n$位满足$a_i = i$。\par
对于一个恰好有$m$位满足$a_i = i$（不妨称之为对排）的排列，我们要
设计系数使得：
\[\sum_{i = 0}^m\binom m i f_i = [m = 0]\]
显然$f_i = (-1)^i$。\par
这不是用原始的瞎猜容斥也能做吗？\par
那么我们加上一个条件：定义每个排列的价值为$p_k$，其中$k$为该排列
的对排数，那么你怎么瞎猜容斥呢？\par
反观容斥系数法，很容易得到公式：
\[\sum_{i = 0}^m\binom m i f_i = p_m\]
然后很容易得到答案：
\[\sum_{i = 0}^n\binom n i (n - i)! f_i\]
不过$f_i$该怎么求呢？原始的做法是$O(n^3)$的高斯消元，如果用下面提
到的二项式反演加上 NTT 可以在$O(n\log n)$时间内搞出来，不过这是下面
内容，此处暂且不表。
\subsection{二项式反演与广义容斥原理例题}
\paragraph{题面}
给定两列数$a_1, a_2, \ldots, a_n$和$b_1, b_2, \ldots, b_n$，
求有多少将两列数两两配对的方案数，使得满足$a > b$的数对恰好有
$k$对。\par
$k\le n\le 2000$，保证给定两列数两两不同。
\paragraph{解析}
“恰好”$k$对不好算，那不妨来算“至少”$k$对的方案数。\par
先将两个序列排序，记$t_i$表示对于$a_i$，有多少$b_i$比他小。\par
那么设DP状态$f_{i, j}$表示对于$\{a_i\}$的前\(i\)项，在其中选
出$j$对使得其匹配满足$a > b$。很显然：
\[f_{i, j} = f_{i - 1, j} + (t_i - j + 1)f_{i - 1, j - 1}\]
然后我们发现$p_i = f_{n, i}(n - i)!$就表示了有至少$i$对满足$a > b$
的方案数，其中选了恰好$j$次的方案会被统计$\binom j i$次。换言之：
\[\sum_{i = m}^n \binom i m g_i = f_m\]
其中$g_i$为恰好$i$对的方案数。眼熟不？这不就是那个广义容斥原理
的式子嘛。套就完事了。
\subsection{MIN-MAX 容斥例题}
\paragraph{题面}
有$n$个球排成一列，初始时都为白色。\par
每次操作都从所有可能的区间里等概率选择一个，将其中的球都染黑。
直到所有球都染黑，这个游戏才结束。\par
求期望的操作次数。\par
\(T(T\le 50)\)组数据，\(n\le 50\)。
\paragraph{题解}
我们要求的东西事实上是一个$\mathrm{E}[\max\{X_i\}]$，其中$X_i$
表示第$i$个球被染黑的时间。这个东西并不好做，我们MIN-MAX容斥一下
，问题就转化成了求被染黑时间的最小值，也就是每个集合第一次有点被
染黑的时间的期望值。\par
然而我们发现求一个集合第一次有点被染黑时间的期望值也并不好做……注
意到对于离散型期望有结论$\mathrm{E}[X]=\sum_{i = 1}^{+\infty}P(X\geq i)$，
而$P(X_i\geq x) = p_i^{x - 1}$（这里$p_i$表示选中区间和我们的那
个集合不相交的概率），也就是说最后的期望是一个无穷级数：
\[\sum_{k = 0}^{+\infty} p_i^k\]\par
利用等比数列求和公式可以得到这个东西就事$\frac{1}{1 - p_i}$（请
注意这里的集合非空，所以$p_i\in [0,1)$，所以这个式子成立），那么
我们接下来就要考虑怎么高效的处理所有集合的贡献。\par
注意到如果不考虑系数的话集合的贡献只和和该集合不相交的区间数有关。
因此我们定义状态$f_{i, j, 0/1}$表示前$i$个点，不和我们选择集合相
交的区间有$j$个，集合奇偶性为$0/1$的情况，转移很容易，然后就做完
了……